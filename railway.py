# railway.py
import os
import uuid
import warnings
import asyncio
from typing import Dict, Optional, TypedDict

from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse

import openai

from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.types import Message, Update
from aiogram.client.default import DefaultBotProperties

# ===================== ENV & helpers =====================

def require_env(name: str) -> str:
    val = os.getenv(name)
    if not val:
        raise RuntimeError(f"Missing required environment variable: {name}")
    return val

OPENAI_API_KEY = require_env("OPENAI_API_KEY")
TELEGRAM_TOKEN = require_env("TELEGRAM_TOKEN")
GPT_ID         = require_env("GPT_ID")                      # asst_...
WEBHOOK_BASE   = "https://checkdoc.up.railway.app"                 # e.g. https://<project>.up.railway.app
WEBHOOK_PATH   = "/telegram/webhook"
WEBHOOK_URL    = (WEBHOOK_BASE.rstrip("/") + WEBHOOK_PATH) if WEBHOOK_BASE else None
TELEGRAM_LINK  = os.getenv("TELEGRAM_LINK", "https://t.me/MedAdvice_bot")

# ===================== OpenAI setup ======================
warnings.filterwarnings("ignore", category=DeprecationWarning)  # –≥–ª—É—à–∏–º Deprecation –¥–ª—è Assistants API
openai.api_key = OPENAI_API_KEY

# ===================== Aiogram (Telegram) ================
bot = Bot(
    token=TELEGRAM_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()

# –ü—Ä–∏–≤—è–∑–∫–∞ thread –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é Telegram, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω—è–ª—Å—è –∫–æ–Ω—Ç–µ–∫—Å—Ç
TG_THREADS: Dict[int, str] = {}

@dp.message(CommandStart())
async def tg_start(m: Message):
    await m.answer("üëã –ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ Telegram-–≤–µ—Ä—Å–∏–∏ CheckDoc. –û–ø–∏—à–∏—Ç–µ —Å–∏–º–ø—Ç–æ–º—ã –∏–ª–∏ –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å.")

@dp.message()
async def tg_text(m: Message):
    text = (m.text or "").strip()
    if not text:
        await m.answer("–ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞.")
        return
    try:
        thread_id = TG_THREADS.get(m.from_user.id)
        if not thread_id:
            # —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π thread –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            thread = await asyncio.to_thread(openai.beta.threads.create)
            thread_id = thread.id
            TG_THREADS[m.from_user.id] = thread_id

        # –∫–ª–∞–¥—ë–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –≤ —Ä–∞–º–∫–∞—Ö thread
        reply = await run_assistant_in_thread(thread_id, text)
        await m.answer(reply or "‚ö†Ô∏è –û—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    except Exception:
        await m.answer("‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")

# ===================== FastAPI (Web + Webhook) ===========
app = FastAPI(title="CheckDoc (Railway)")

# –ø—Ä–æ—Å—Ç–µ–π—à–µ–µ in-memory: session_id -> thread_id (–¥–ª—è –≤–µ–±-—á–∞—Ç–∞)
WEB_SESSIONS: Dict[str, str] = {}

def _html_page(gpt_id: str, tg_link: str) -> str:
    return f"""<!doctype html>
<html lang="ru"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CheckDoc ‚Äî –í–µ–±-—á–∞—Ç</title>
<style>
:root {{ --brand:#0ea5e9; --bg:#f7f7fb; --text:#111827; --muted:#6b7280; }}
* {{ box-sizing: border-box; }}
body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;background:var(--bg);color:var(--text)}}
header{{background:var(--brand);color:#fff;padding:16px 20px}}
main{{max-width:900px;margin:22px auto;padding:0 16px}}
.card{{background:#fff;border-radius:14px;box-shadow:0 1px 8px rgba(0,0,0,.06);padding:16px}}
.row{{display:flex;gap:10px}}
.input{{flex:1;padding:12px 14px;border:1px solid #ddd;border-radius:10px;font-size:16px}}
.btn{{background:var(--brand);color:#fff;border:none;border-radius:10px;padding:12px 16px;cursor:pointer}}
.btn:disabled{{opacity:.6;cursor:not-allowed}}
.bubble{{border-radius:12px;padding:12px 14px;margin:10px 0;max-width:90%}}
.user{{background:#e9f5ff;margin-left:auto}}
.bot{{background:#f0f0f3}}
.toprow{{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}}
.link{{text-decoration:none;background:#111827;color:#fff;padding:8px 10px;border-radius:8px}}
.muted{{color:var(--muted);font-size:14px}}
footer{{text-align:center;color:var(--muted);margin:30px 0 14px;font-size:13px}}
#log{{min-height:280px}}
.small{{font-size:12px;color:var(--muted);margin-top:8px}}
</style>
</head>
<body>
<header><h2>üíä CheckDoc ‚Äî –í–µ–±-—á–∞—Ç</h2></header>
<main>
  <div class="card">
    <div class="toprow">
      <div class="muted">–í–µ–±-—á–∞—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç Telegram-–±–æ—Ç–∞</div>
      <a class="link" href="{tg_link}" target="_blank" rel="noopener">–ü–µ—Ä–µ–π—Ç–∏ –≤ Telegram</a>
    </div>
    <div id="log"></div>
    <div class="row">
      <input id="msg" class="input" placeholder="–û–ø–∏—à–∏—Ç–µ —Å–∏–º–ø—Ç–æ–º—ã –∏–ª–∏ –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å‚Ä¶"/>
      <button id="send" class="btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
    </div>
    <div class="small">Assistant ID: {gpt_id}</div>
  </div>
  <footer>¬© CheckDoc</footer>
</main>
<script>
const log = document.getElementById('log');
const msg = document.getElementById('msg');
const btn = document.getElementById('send');

function addBubble(text, role) {{
  const d = document.createElement('div');
  d.className = 'bubble ' + (role === 'user' ? 'user' : 'bot');
  d.textContent = text;
  log.appendChild(d);
  log.scrollTop = log.scrollHeight;
}}

async function send() {{
  const text = msg.value.trim();
  if (!text) return;
  addBubble(text, 'user');
  msg.value = '';
  btn.disabled = true;
  try {{
    const r = await fetch('/chat', {{
      method: 'POST',
      headers: {{ 'Content-Type': 'application/json' }},
      body: JSON.stringify({{ text }})
    }});
    const j = await r.json();
    addBubble(j.reply || '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞', 'assistant');
  }} catch(e) {{
    addBubble('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏', 'assistant');
  }} finally {{
    btn.disabled = false;
  }}
}}

btn.addEventListener('click', send);
msg.addEventListener('keydown', e => {{ if (e.key === 'Enter') send(); }});
</script>
</body></html>"""

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    # cookie –¥–ª—è –≤–µ–±-—Å–µ—Å—Å–∏–∏
    sid = request.cookies.get("sid") or str(uuid.uuid4())
    html = _html_page(GPT_ID, TELEGRAM_LINK)
    resp = HTMLResponse(html)
    resp.set_cookie("sid", sid, httponly=True, samesite="lax", max_age=60*60*24*14)
    return resp

class ChatIn(TypedDict):
    text: str

@app.post("/chat")
async def chat(request: Request):
    data: dict = await request.json()
    user_text: str = (data.get("text") or "").strip()
    if not user_text:
        return JSONResponse({"reply": "–í–≤–µ–¥–∏—Ç–µ –≤–æ–ø—Ä–æ—Å."})
    sid = request.cookies.get("sid") or str(uuid.uuid4())
    thread_id = get_or_create_web_thread(sid)
    try:
        reply = await run_assistant_in_thread(thread_id, user_text)
        return JSONResponse({"reply": reply or "‚ö†Ô∏è –û—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω."})
    except Exception:
        return JSONResponse({"reply": "‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑."})

@app.post(WEBHOOK_PATH)
async def telegram_webhook(request: Request):
    data = await request.json()
    upd = Update.model_validate(data)
    await dp.feed_update(bot, upd)
    return JSONResponse({"ok": True})

@app.get("/health")
async def health():
    return {"ok": True, "webhook_set": bool(WEBHOOK_URL)}

@app.on_event("startup")
async def on_startup():
    # –°—Ç–∞–≤–∏–º –≤–µ–±—Ö—É–∫ Telegram, –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –¥–æ–º–µ–Ω
    if WEBHOOK_URL:
        await bot.set_webhook(WEBHOOK_URL)
        print(f"‚úÖ Telegram webhook set: {WEBHOOK_URL}")
    else:
        print("‚ö†Ô∏è WEBHOOK_BASE –Ω–µ –∑–∞–¥–∞–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—é —É—Å—Ç–∞–Ω–æ–≤–∫—É –≤–µ–±—Ö—É–∫–∞. "
              "–î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –≤ Railway –∏ —Å–¥–µ–ª–∞–π—Ç–µ Redeploy.")

# ===================== Assistants helpers =================

def get_or_create_web_thread(session_id: str) -> str:
    th = WEB_SESSIONS.get(session_id)
    if not th:
        thread = openai.beta.threads.create()
        th = thread.id
        WEB_SESSIONS[session_id] = th
    return th

async def run_assistant_in_thread(thread_id: str, user_text: str) -> Optional[str]:
    """
    –í–µ–¥–µ–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞ –≤ —Ä–∞–º–∫–∞—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ thread (–≤–µ–±-—á–∞—Ç –∏ Telegram).
    """
    # —Å–æ–∑–¥–∞—ë–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    await asyncio.to_thread(
        openai.beta.threads.messages.create,
        thread_id=thread_id, role="user", content=user_text
    )
    # –∑–∞–ø—É—Å–∫–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    run = await asyncio.to_thread(
        openai.beta.threads.runs.create,
        thread_id=thread_id, assistant_id=GPT_ID
    )
    # –∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    while True:
        status = await asyncio.to_thread(
            openai.beta.threads.runs.retrieve,
            thread_id=thread_id, run_id=run.id
        )
        if status.status == "completed":
            break
        if status.status == "failed":
            return "‚ùå –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –Ω–µ —Å–º–æ–≥ –æ—Ç–≤–µ—Ç–∏—Ç—å."
        await asyncio.sleep(0.6)
    # —á–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
    msgs = await asyncio.to_thread(openai.beta.threads.messages.list, thread_id=thread_id)
    for m in msgs.data:
        if m.role == "assistant" and m.content:
            part = m.content[0]
            if hasattr(part, "text") and hasattr(part.text, "value"):
                return part.text.value
    return None
